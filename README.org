* C-Json
  This is intend to be a library designed to provide total control
  over [[https://www.json.org/][JSON]] data structure in *C*.

** Status
   This project is currently done for me. I have nothing more to
   add. Although, no unit tests were made because I'm lazy,
   registering new test is straigh forward and quick, see the *Testing* section for
   more info on that. That been said, I might add some tests in a
   distant future, if needed.  

** Data Structure
   *C-Json* provides 3 data structures. *JSON_Type*, *JSON_Dict* and
   *JSON_List*. For every structures, many useful functions are
   provided to ensure speed and security of data manipulation. See the
   documentation for more info.

** Parser
   *C-Json* implements a parser generated by [[https://www.gnu.org/software/bison/][GNU Bison]]. This parser
   can parse any file descriptor that contain valid JSON data. It can
   either parse a global list or a global dictionary.

** I/O
   *C-Json* provides basic *IO* operations on its data structures. See
   the documentaion for more info.

* Dependency
   You will need to have [[https://www.gnu.org/software/bison/][GNU Bison]] in order to be able to compile the
   library. There's no need to have *lex* or *flex*, because the
   lexer, that the parser uses, is implemented by hand.

* Build
   To build the library, simply use [[https://www.gnu.org/software/make/][GNU make]] utiliy by running *make*.

* Install
   After [[*Build][building]] the library, run *sudo make install*. This will copy
   all headers files in */usr/local/include/JSON* and the builded
   shared library in */usr/local/lib/libJSON.so*.

* Testing
  To create new tests, create a file under /tests/inc/. That file
  should be name /test-[name].h/ and write your tests. In order to
  execute the tests, you have to include your file in
  /test-to-include.h/ under the header *Includes Tests*. After that,
  use the macro ~TEST~ and pass as parameter the name of your function
  in the list variable *tests*. Your test is now register as a worker
  that will have his own thread when tests are executed.

  Your test should have the following prototype: 
  #+BEGIN_SRC C
  void* My_Test(void*)
  #+END_SRC

  The parameter is the adress of a ~struct JSON_WorkerArg~ that can be
  pass in the ~TEST~ macro during registation. The return value is the
  adress of a ~struct JSON_WorkerRetVal~. It should contain the status
  code of the test, /i.e/ if it has succeed or not, the name of the
  test and a buffer containing useful information to display.

** Useful Macros
   - TEST(NAME, ...) :: Register a test named NAME with (...) args.
   - INIT_WORKER(PTR, NAME, BUFF, OK) :: Initiliaze a JSON_WorkerRetVal.

   Many more useful macros can be found under /inc/utils.h/.
   
** Exemple
#+BEGIN_SRC c
  // test-foo.h
  (...)
  
  void* My_Test(void*)
  {
    /*
     * Name: "Foo Test"
     * Buff: "\0"
     * Ok  : 1
     */
    INIT_WORKER(val, "Foo Test", "\0", 1);
    
    return val;
  }
  
  (...)
#+END_SRC

#+BEGIN_SRC c
  // test-to-include.h
  (...)
  
  /*=============================================================================+
  |                               Includes Tests                                |
  +=============================================================================*/
  #include "test-list.h"
  #include "test-foo.h"  // Here we include our test.

  JSON_Testers test[] =
  {
    (...),
    TEST(My_Test), // We register one of our test here.
    {NULL}         // Very important, last test should always be NULL.
   };
  
   (...)
#+END_SRC

* Documentation
   The documentation is generated by [[http://www.stack.nl/~dimitri/doxygen/][Doxygen]]. To generate the
   documentation, run *make doc*.

* Usage
#+BEGIN_SRC c
  #include <JSON/json.h>   // Main json structure
  #include <JSON/parser.h> // Bison parser
  #include <JSON/io.h>     // io manipulaation

  #define DICT_SIZE 64
  #define LIST_SIZE 128

  size_t hashType(const char* key);

  int main(int argc, char* argv[])
  {
    JSON_Type* type = NULL;

    FILE* in = fopen(argv[1], "r");

    ////////////////////////////////////////////////////////////////////////////
    // The parser need the following arguments:
    // 1. A pointer to pointer of JSON_Type that will store the overall parsing
    // 2. A file descriptor to read from
    // 3. A hash function that will hash value for JSON_Dict structures
    // 4. The number of buckets for JSON_Dict structures during parsing
    // 5. The initial size of JSON_List structures during parsing
    ////////////////////////////////////////////////////////////////////////////
    if (in)
      JSON_parse(&type, in, &hashType, DICT_SIZE, LIST_SIZE);

    fclose(in);

    if (!type)
      return 1;

    JSON_PrintType(type, stdout);
    // Do stuff with type here

    JSON_FreeType(type);

    fclose(out);

    return 0;
  }

  /*  Primitive hash function  */
  size_t hashType(JSON_HashKey key)
  {
    size_t hash = 0;

    while (*key)
      hash += (size_t)(*(key++));

    return hash;
  }
#+END_SRC
